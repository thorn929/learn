<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<body>
<script>

//    var obj = {a: 1};
//    var copy = Object.assign({}, obj);
//
//    copy.a  =2
//    console.log(copy);
//    console.log(obj);


//
// function test() {
//     'use strict';
//
//     let obj1 = { a: 0 , b: { c: 0}};
//     let obj2 = Object.assign({}, obj1);
//     console.log(JSON.stringify(obj2)); // { a: 0, b: { c: 0}}
//
//     obj1.a = 1;
//     console.log(JSON.stringify(obj1)); // { a: 1, b: { c: 0}}
//     console.log(JSON.stringify(obj2)); // { a: 0, b: { c: 0}}
//
//     obj2.a = 2;
//     console.log(JSON.stringify(obj1)); // { a: 1, b: { c: 0}}
//     console.log(JSON.stringify(obj2)); // { a: 2, b: { c: 0}}
//
//     // 这里就看出来了
//     obj2.b.c = 3;
//     console.log(JSON.stringify(obj1)); // { a: 1, b: { c: 3}}
//     console.log(JSON.stringify(obj2)); // { a: 2, b: { c: 3}}
//
//     // Deep Clone
//     obj1 = { a: 0 , b: { c: 0}};
//     let obj3 = JSON.parse(JSON.stringify(obj1));
//     obj1.a = 4;
//     obj1.b.c = 4;
//     console.log(JSON.stringify(obj3)); // { a: 0, b: { c: 0}}
// }
//
// test();


        // Shape - 父类(superclass)
        function Shape() {
            this.x = 0;
            this.y = 0;
        }

        // 父类的方法
        Shape.prototype.move = function(x, y) {
            this.x += x;
            this.y += y;
            console.info('Shape moved.');
        };

        // Rectangle - 子类(subclass)
        function Rectangle() {
            Shape.call(this); // call super constructor.
        }

        // 子类续承父类
        Rectangle.prototype = Object.create(Shape.prototype);
        Rectangle.prototype.constructor = Rectangle;

        var rect = new Rectangle();

        console.log('Is rect an instance of Rectangle?', rect instanceof Rectangle); // true
        console.log('Is rect an instance of Shape?', rect instanceof Shape); // true


        rect.move(1, 1); // Outputs, 'Shape moved.'


        // 如果你想继承到多个对象
        function MyClass() {
            SuperClass.call(this);
            OtherSuperClass.call(this);
        }
        // 继承一个类
        MyClass.prototype = Object.create(SuperClass.prototype);
        // 混合其它
        Object.assign(MyClass.prototype, OtherSuperClass.prototype);
        // 重新指定constructor
        MyClass.prototype.constructor = MyClass;

        MyClass.prototype.myMethod = function() {
            // do a thing
        };

        console.log(this)







</script>
</body>
</html>